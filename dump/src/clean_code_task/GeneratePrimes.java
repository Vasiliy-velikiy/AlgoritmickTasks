package clean_code_task;
/**
 * Класс генерирует простые числа в диапазоне до максимального значения,
 * заданного пользователем, по алгоритму "Решета Эратосфена".
 * <p>
 * Эратосфен Киренский, 276 год до н.э., Ливия -- * 194 год до н.э., Александрия.
 * Первый ученый, вычисливший длину земного меридиана. Известен своими работами
 * о календарях с високосным годом, заведовал Александрийской библиотекой.
 * <p>
 * Алгоритм весьма прост. Берем массив целых чисел, начиная с 2, и вычеркиваем
 * из него все числа, кратные 2. Находим следующее невычеркнутое число
 * и вычеркиваем все его кратные. Повторяем до тех пор, пока не дойдем
 * до квадратного корня верхней границы диапазона.
 *
 * @author Альфонс
 * @version 13 февраля 2002 u
 */

import java.util.*;

public class GeneratePrimes {

    public static void main(String[] args) {
        printElem(generatePrimes(21));
    }

    private static void printElem(int[] generatePrimes) {
        for (int a : generatePrimes) {
            System.out.print(a + " ");
        }
    }

    /**
     * @param maxValue - верхняя граница диапазона.
     */
    public static int[] generatePrimes(int maxValue) {
        if (maxValue >= 2) // Единственно допустимый случай
        {
            // Объявления
            int s = maxValue + 1; // Размер массива
            boolean[] f = new boolean[s];
            int i;
            // Инициализировать массив значениями true.
            for (i = 0; i < s; i++)
                f[i] = true;
            // Удалить числа, заведомо не являющиеся простыми.
            f[0] = f[1] = false;
            // Отсев
            int j;
            for (i = 2; i < Math.sqrt(s) + 1; i++) {
                if (f[i]) // Если элемент i не вычеркнут, вычеркнуть кратные ему.
                {
                    for (j = 2 * i; j < s; j += i)
                        f[j] = false; // Кратные числа не являются простыми.
                }
            }
            // Сколько простых чисел осталось?
            int count = 0;
            for (i = 0; i < s; i++) {
                if (f[i])
                    count++; // Приращение счетчика
            }
            int[] primes = new int[count];
            // Переместить простые числа в результат
            for (i = 0, j = 0; i < s; i++) {
                if (f[i]) // Если простое
                    primes[j++] = i;
            }
            return primes; // Вернуть простые числа
        } else // maxValue < 2
            return new int[0]; // Вернуть пустой массив при недопустимых входных данных.
    }


}
